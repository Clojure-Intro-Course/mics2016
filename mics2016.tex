% This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
% 
%----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
%
%  However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
%
%---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org 
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure} 
\usepackage{hyperref}
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\hfcomment}[1]{\textcolor{Teal}{\comment{Henry: {#1}}}}
\newcommand{\thcomment}[1]{\textcolor{Coquelicot}{\comment{Thomas: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE. 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden. 
% --- End of Author Metadata ---

\title{Designing a Comparative Usability Study of Error Messages}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Henry Fellows, Thomas Hagen, Sean Stockholm, and Elena Machkasova \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
fello056@morris.umn.edu,..., elenam@morris.umn.edu
}
\date{}
\maketitle
\thispagestyle{empty}

\section*{\centering Abstract}
Error messages are the only form of response that programmers get from malfunctioning programs. More experienced programmers often develop intuition about what error messages actually mean, but novices only have the content of the error message. Our research focuses on two functional programming languages in the Lisp family, their current or potential use in introductory CS classes, and specifically on the quality of their error messages for beginner CS students. 

The languages we will be comparing are a subset of Racket called beginning student language, and Clojure. Beginning student language is a language designed for introductory students using the “How to Design Programs 2” curriculum, with error messages that are designed for novices. Clojure is a Lisp built on top of the Java programming language which better supports concurrent and parallel programming and has been rapidly gaining popularity in industry. However, Clojure was not developed with beginner programmers in mind: its native error messages are often just Java error messages that don’t make sense to programmers without Java background. Our previous work with Clojure has built an alternative error messages system that we think may be more useful to beginner CS students. 

Our work is a part of the ClojurEd project which aims to use Clojure to teach an introductory CS course. One of the project goals is to provide introductory students with understandable error messages. We attempt to achieve this goal by rephrasing Java errors in terms that are familiar to new Clojure programmers. As a simple example, we replace references to specific Java numeric types, such as “int” and “double”, with just the term “number”. The next stage of the project is to evaluate how well the new messages work for beginner programmers. 

In order to evaluate how helpful our error messages are to beginners, we have designed a usability study comparing the proposed and standard Clojure error messages to each other and to Racket error messages. There are very few published usability studies of error messages and very few guidelines for evaluating quality of error messages, thus we have developed methodology for comparing error messages in two similar languages. We evaluate the effectiveness of our error messages by giving students, who are familiar with Racket, erroneous code in both Racket and Clojure. We will then observe how the information presented within the error messages helps them to correct the erroneous code. Effectiveness of error messages will primarily be measured by the number of code samples successfully corrected by students, as well as the number of attempts is takes a student to correct the errors. 

In this paper we present the details of the study and the approaches to developing code samples that allow us to compare error messages systems. We also present and discuss preliminary results of the usability study. 
\emcomment{This would need to be modified after we've finished the paper}
\newpage
\setcounter{page}{1}

\section{Introduction}\label{sec:intro}
Error messages are the primary form of response that programmers get from malfunctioning programs. 
Experienced programmers have the background to understand what error messages actually mean, but novices only have the content of the error message. 
While interactions with errors in a programming language are an essential part of a programmer's experience, quite often error handling in a language is not very well thought through: error messages use inconsistent terminology, are ambiguous or misleading, and do not provide enough detail. 
Beginner programmers find error messages unhelpful.
Anecdotal evidence (informal questioning of about 10 CS students and almuni by the authors) indicates that novice programmers often do not even realize that an error message may contain useful information, except perhaps the line number; some ignore these messages entirely. 
Consistently with the general programming languages community undervaluing of error messages quality, there is very little formal study of usability of error messages for beginners and very little methodology developed. The notable exception is the development and study of beginner-friendly error messages in the Racket programming language \cite{Marceau:2011,Marceau:2011-2}. 

Clojure is a functional language in the Lisp family released in 2007. 
Clojure is translated to Java bytecode, employing the Java Virtual Machine (JVM) as its interpreter, and features Java interop: the ability to use Java code directly in Clojure code. 
It quickly gained popularity, is widely used in industry and in open-source projects, and features a large community of developers with three major early conference (two in the U.S. and one in Europe), as well as numerous smaller gatherings and meetups. 

As a Lisp, Clojure has simple syntax and dynamic type system, and therefore may be a promising option in a functional-first approach to teaching programming \emcomment{add a citation here for FP first}. However, due to its implementation over Java, Clojure is notorious for its cryptic and unintuitive error messages. Clojure errors are just Java exceptions, and therefore are phrased in terms of Java types (e.g. \texttt{java.lang.Number}) and Java operations, such as typecasting. They also come with Java stack trace which can be particularly verbose in Clojure since functional languages tend to have a large number of function calls on the stack. Clojure error messages are often confusing even to experienced programmers, and are a barrier for beginners. 

In the last few years there has been a large community effort to address this issue. Several Clojure IDEs come with their own error processing system that filters our Clojure internal functions from the stack trace. There's been work done on improving error messages for macros \emcomment{cite} However, these improvements address the needs of more experienced programmers by continuing using Java types and more advanced terminology, and leave out those for whom Clojue would serve as the first introduction to programming. Our work on error messages aims at addressing beginners' needs.  

\emcomment{Just give an overview of the rest}

	\subsection{Goals}\label{sec:goals}
This work is a part of a larger project on making Clojure more accessible to beginners. In particular, we have developed an alternative system of error messages that do not use Java datatypes and other terminology that beginner programmers would not be familiar with. 
\emcomment{a couple of examples}

While these messages seem to be an improvement, we would like to examine two hypotheses about our alternative system of Clojure error messages:
\begin{enumerate}
\item It is easier to understand than Clojure native error messages.
\item It is at least as helpful as the system of error messages in the Racket programming language. \emcomment{do we need to switch this with the next section, or do we give a quick overview of Racket here?}
\end{enumerate}
To test these hypotheses, we have developed a comparative usability study that compares our system of error messages to the native Clojure error messages and to those in the Racket programming language. We use a series of erroneous code fragments that the test subjects need to correct, and measure how many fragments they have successfully fixed and how may steps it took them to fix the issue or make edits that make progress towards the solution. 
Study subjects are undergraduate students with Racket background, with none, or very little, Clojure background. 
Detailed description of this process is given in Section~\ref{sec:setup}. 

A statistically significant higher number of fixed code fragments and a lower number of attempts for our error messages system, compared to the native Clojure system, would indicate that our error messages are easier for students to understand. Additionally we are measuring the difference between either one of the Clojure error messages systems and the Racket messages. Racket error messages were specifically developed to be helpful for beginners. Thus, a comparison to Racket messages would indicate how our error messages compare to the expectations of error messages for beginner-friendly functional languages. 

\emcomment{Need to mention the IRB exemption somewhere: one of the Racket papers does.}


	\hfcomment{This needs to describe error messages briefly. Reference previous project.}
\section{Languages}\label{sec:lang}
	\hfcomment{Henry}

	\subsection{Overview of Lisp}\label{sec:lisp}

	Lisp is a family of programming languages that dates from 1958, based on Alonzo Church's lambda calculus 
	%\emcomment{Lisp is definitely based on the lambda calculus, but it wasn't created from it. In particular, lambda calculus is call by name (in its classical form)}
	 by John McCarthy. Lisp was the first language where the internal representation of the program was in the same data structures the program was written in. \hfcomment{???} Lisp has a distinctive fully parenthesized prefix notation, where all code and data are written as expressions in the form:
	\begin{verbatim}
	(<function-name> <argument 1> <argument 2> ... <argument N>)
	\end{verbatim}
Almost all operations are functions. Addition, for instance, is a function that can be applied to any number of arguments.
	\begin{verbatim}
	(+ 2 4 6 8)
	-> 20
	\end{verbatim}
Note that \texttt{->} indicates the result of computations in the Lisp interpreter. Lists in lisp are commonly created by using the list function
 	\begin{verbatim}
	(list 2 4 6 8)
	-> '(2 4 6 8)
	\end{verbatim}
The return value \texttt{'(2 4 6 8)} uses the single quote \texttt{'} to indicate that the expression should not be evaluated (doing so would attempt to apply the number \texttt{2} as a function), but instead it should be treated as list \hfcomment{wrong, but close enough to the truth?}	
	\begin{verbatim}
	(list 2 4 6 8)
	-> '(2 4 6 8)
	\end{verbatim}
	
	Felleisen et al~\cite{Felleisen:2004} have made an excellent case for using a Lisp as a programming language in an introductory CS class
	\emcomment{To be fair, though, they weren't the first ones to use it (SICP was the prior approach)}:
the first language new programmers will use. Lisp offers a simple
syntax and introduces students to modularity, abstraction, and
data-driven program design while developing good programming
practices by being explicit about program design principles.
Teaching these concepts in introductory courses creates a foundation that later classes can build upon in  while teaching popular imperative and object-oriented languages.~\cite{Bieniusa:2008}.\hfcomment{grab from mics 2015 bib} 

\emcomment{We use hashmaps; need to mention those}
	\subsection{Differences between Racket and Clojure}\label{sec:diff}
	
Racket \hfcomment{Beginning student language?} and Clojure, while still lisps, satisfy different design goals. 
Racket is designed for introductory students, while Clojure focuses on concurrency and integration with the Java virtual machine. 
The differing purposes of these language have created divides in the syntax and idioms of Racket and Clojure.
 The differences begin at definition of variables; Clojure defines functions with the following syntax

\begin{verbatim}
	(defn function-name [<argument 1> ... <argument N>] (expression))
	e.g
	(defn plus-four [x] (+ x 4))
\end{verbatim}
Racket uses this syntax:
\begin{verbatim}
	(define (function-name <argument 1> ... <argument N>) (expression))
	e.g
	(define (plus-four x) (+ x 4))
\end{verbatim}

Racket and Clojure both have associative datatypes, and Clojure actually has two. We used hashmaps in the study, simply because they are far more common than the alternative.
Hashmaps in Clojure are a collection of key-value pairs: 

\begin{verbatim}
	{key value, key value, key value}
\end{verbatim}

Hashmaps commonly use keywords. Keywords are simple names that have a colon in front.
An example of a hashmap using keywords follows: 

\begin{verbatim}
	{:a 1, :b 2, :c 3}#<position>
	
	(:a {:a 1, :b 2, :c 3})
	-> 1
\end{verbatim}

The keywords in the above hashmap are: \texttt{:a}, \texttt{:b}, and \texttt{:c}.
Keywords are often used as keys within hashmaps. 
When used as a function on a hashmap, keywords return the value associated with the keyword. 
In the above example, \texttt{:a} is bound to \texttt{1},\texttt{:b} is bound to \texttt{2}, and \texttt{:c} is bound to \texttt{3}.


Racket uses structs as its associative datatype, which has the following syntax:
\begin{verbatim}
	(struct position (x y))
	
	(position 75 42)
	-> #<position>
\end{verbatim}
Structs automatically generate an accessor function for each field in the structure.
\begin{verbatim}
	(position-x (position 75 42))
	-> 75
\end{verbatim}
\section{Usability Study}\label{sec:study}
	\subsection{Objectives}\label{sec:obj}
	\hfcomment{Elena}
	\subsection{Experimental Setup}\label{sec:setup}

The study is split into two parts; Racket review and testing, and Clojure education and testing.
The goal of each section will be to introduce the languages basic functionality and then test the participants ability to correctly answer questions in that language.

Outline:
\begin{itemize}
\item Participant will be assigned an instructor
\item Participant will be given a review of Racket
\item Participant will be given a series of questions in Racket to answer
\item The error messages of the Racket questions will be the default messages
\item Participant will be taught an overview of Clojure
\item Participant will be given a series of questions in Clojure to answer
\item Each participant will randomly receive only our error messages or  only Clojure's default error messages
\item The errors participants create and their current code will be captured via screencap at a regular intervals
\item Each instructor will document their participants actions and errors in general
\item The participants will be asked a series of questions about the tests at the end
\end{itemize}

REVIEW

The overall purpose of each instructional session is to both ensure that the participants have enough fundamental knowledge of the language presented to them to have a basic understanding of the problems. 
In addition, the session should also ensure a relatively similar level of familiarity with both Clojure and Racket among all participants. 
Each participant in the study will go through the process of reviewing and testing individually in order to minimize outside influence from other participants or distractions. 
Because of this, the participant's experiences must be parallel with each other both in terms of the environment and the materials provided such as not to create bias.
The Racket review section will be a reintroduction to participants, as they should already have a base knowledge of Racket from previous courses taken.
The participants should have little or no knowledge of Clojure when coming into the study, so the Clojure lesson will focus more on drawing similarities from Racket and basic function explanations.
The core topics to cover for each language are syntax such as prefix notation, higher order functions, function definition, and recursion.

TESTING

After the education part the participants will be assigned to a computer where their actions will be monitored by a reviewer. 
From here, they will be directed to connect to a website we have constructed that will present them with a series of problems to solve. 
Participants will not be allowed to consult outside sources, the reviewer, or other participants during this period of the study except for the language's public API. 
The participants will also have access to either Racket's built-in IDE or a Clojure project in LightTable depending on which language they are being tested on.
The website they connect to pulls its questions from a set of parallel questions between Clojure and Racket we have constructed, so that for every question in Racket there is an computationally equal question in Clojure and vice-versa.
Each question pair has a difficulty rating associated with it, with one being the easiest questions and 5 being the hardest questions.
When a new participant logs into the website, it constructs both the Racket and Clojure tests to present by randomly selecting question-pairs from the pool. 
The program must choose set amounts of questions from each difficulty, such as three level one questions, one level two question, 2 level three questions, ect, every time it creates tests. 
As an example of this, assume a student sits down and logs into the website to take a test.
The website goes to construct the test under the restriction that every set of test questions it creates, no matter what language, must have three level one questions from that language. 
It checks the pool of level one questions and sees there are seven possible level one question-pairs for the program to use.
We can think about the pool like this,

LEVEL 1: (C1,R1), (C2,R2), (C3,R3),...,(C7,R7)

where a question pair is C1 (Clojure question 1) and R1 (Racket question 1), which are essentially the same question in different languages. 

The website then randomly selects three level one question-pairs from the seven, removes them from the pool, and adds the Racket version of those questions to the set of Racket questions for the test.
The website constructs the rest of the Racket test in a similar fashion for each difficulty level by randomly selecting question-pairs, adding the Racket version to the  Racket test, and removing the pair from the pool.
Even though we are only using the Racket version of the question in the Racket test, we still remove the whole pair from the pool so that we don't end up duplicating questions.
If we did not remove the pair, our participant could end up with question R1 in their Racket test and C1 in their Clojure test, effectively giving them the same questions twice.
After the Racket test is made, the website goes to create the Clojure test and moves to add three new level one questions to it.
Since we have already taken out three question-pairs from the pool of seven, there are only four level one question-pairs left to use.
The website randomly select three questions out of the remaining four that have not been used and puts them into the Clojure Test.
In the end our tests for this participant may end up looking something like this; 

Racket Test: R1, R6, R3

Clojure Test: C2, C5, C7


	The participants will be allocated a time limit to answer the questions on each test. 
They are allowed to try as many times as needed on each questions and they are allowed to skip past questions with the possibility of coming back to them later on. 
Before taking their Clojure test each participant will secretly be assigned to receive either Clojure's default error messages or our custom Clojure error messages.
While testing, the computer will take a screenshot periodically and the reviewer will take notes on what the participant does while solving the problems.
After the finishing all of the questions, the participant will be asked a series of questions related to the tests such as, "What part of the tasks were easy for you? What parts were hard?".
After the question period of the study, we will now have a collection of screen captures from each participant detailing the process solving the problems, notes on their problem solving process, and participant opinion on the challenges of the study.
From these we can begin to gauge the significance of the error messages in their problem solving processes. 

\section{Principles of Question Selection}\label{sec:select}
	\hfcomment{Henry + Elena}
	\subsection{Selecting Meaningful Accessible Questions}\label{sec:meaning}
	\hfcomment{Elena}
	\subsection{Question parallelism}\label{sec:parallel}
	\hfcomment{Henry}
	both features - don't use vectors, cond, no loop recur in clojure
	One of the overarching themes of this study was the difficulty in creating questions that had similar meaning, errors, and syntax in both Clojure and Racket.
	 Often, our questions are somewhat less than idiomatic because of the constraints imposed by the short time commitment we intended for the study.
	  For instance, we only use lists in our questions, where idiomatic Clojure prefers vectors, which combine the best features of arrays and lists.
	   Reducing the amount of review and potential sources of confusion was paramount. 
	   For instance, Clojure doesn't support tail recursion properly because of the limitations of the Java virtual machine.
	    In order to create tail-recursive structures, idiomatic Clojure uses a construct called loop recur to bypass this limitation. \hfcomment{Cond?}
\section{Examples}\label{sec:examples}
	\hfcomment{Sean, Thomas}
	
	This first example is categorized as a medium problem. 
	It is at this difficulty because of the use of a higher order function.
	The error in this example can be fixed by replacing \texttt{(even \%1)} with \texttt{(even \%2)} 
	We want to see if the error message can help the subject to recognize that we should be testing the parity of the element we are adding to the list, and not the parity of the list itself, because that would not make sense. 
	
	Problem statement:
		Make the following function work so that all the test cases below evaluate to true.
	
	Clojure code:
\begin{verbatim}
		(defn filter-even [lis] 
			(reduce #(if (even %1) (cons %2 %1) %2) '() lis))
\end{verbatim}
	Racket code:
\begin{verbatim}
		(define (filter-even lis) 
			(foldl (lambda (x y) (if (even? y) (cons x y) y)) '() lis))
\end{verbatim}
	In this case, Racket and Clojure have identical test cases: 

\begin{verbatim}
		(= '(2 4 6 8) (filter-even '(1 2 3 4 5 6 7 8 9)))
		(= '() (filter-even '(1 3 5 7 9)))
\end{verbatim}

	Our error:
\begin{verbatim}
		Error: In function even?, the first argument () must be an integer number 
		but is a list.
\end{verbatim}

	Standard Clojure error:
\begin{verbatim}
		CompilerException java.lang.RuntimeException: Unable to resolve symbol: 
		even in this context, 	compiling:(/tmp/form-init1838929281200029831.clj:1:38) 
\end{verbatim}

	Racket error:
\begin{verbatim}
		even?: expects integer, given '()
\end{verbatim}


	We have categorized this second example is an easy problem.
	The error in this example can be fixed by replacing the function \texttt{first} with \texttt{rest}.
	The Clojure code in this example is done in a non-ideamatic way so that it is more comparable to the Racket code.
	We hope our error message will help the subject to realize that they should be dealing with a sequence, not an element of a sequence. 
	
	
	

	Problem statement:
		Make the following function work so that all the test cases below evaluate to true. 
		
		
	Clojure code:
\begin{verbatim}
		(defn my-length [lst]
 			(if (empty? lst) 0 (+ 1 (my-length (first lst)))))
\end{verbatim}
	Racket code:
\begin{verbatim}
		(define (my-length lst)
  			(cond
 				[(empty? lst) 0]
   				[else (+ 1 (my-length (first lst)))]))
\end{verbatim}
	Clojure test cases:
\begin{verbatim}
		(= (my-length '(5 4 3 2 1)) 5)
		(= (my-length '()) 0)
		(= (my-length '(1 3 5 7 9 11)) 6)
\end{verbatim}
	Racket test cases:
\begin{verbatim}
		(equal? (my-length '(5 4 3 2 1)) 5)
		(equal? (my-length '()) 0)
		(equal? (my-length '(1 3 5 7 9 11)) 6)
\end{verbatim}
	Our error:
\begin{verbatim}
		Error: Don't know how to create a sequence from a number.
\end{verbatim}
	Standard Clojure error:
\begin{verbatim}
		IllegalArgumentException Don't know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:528)

\end{verbatim}
	Racket error:
\begin{verbatim}
		first: expects a non-empty list; given: 1
		
\end{verbatim}


\section{Conclusion}\label{sec:conclusion}
	\hfcomment{Elena}

\bibliographystyle{acm}
\bibliography{mics2016}

% That's all folks!
\end{document}
