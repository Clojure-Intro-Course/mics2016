% This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
% 
%----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
%
%  However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
%
%---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org 
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure} 
\usepackage{hyperref}
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\hfcomment}[1]{\textcolor{Teal}{\comment{Henry: {#1}}}}
\newcommand{\thcomment}[1]{\textcolor{Coquelicot}{\comment{Thomas: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE. 
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden. 
% --- End of Author Metadata ---

\title{Designing a Comparative Usability Study of Error Messages}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Henry Fellows, Thomas Hagen, Sean Stockholm, and Elena Machkasova \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
fello056@morris.umn.edu,..., elenam@morris.umn.edu
}
\date{}
\maketitle
\thispagestyle{empty}

\section*{\centering Abstract}
Error messages are the only form of response that programmers get from malfunctioning programs. More experienced programmers often develop intuition about what error messages actually mean, but novices only have the content of the error message. Our research focuses on two functional programming languages in the Lisp family, their current or potential use in introductory CS classes, and specifically on the quality of their error messages for beginner CS students. 

The languages we will be comparing are a subset of Racket called beginning student language, and Clojure. Beginning student language is a language designed for introductory students using the “How to Design Programs 2” curriculum, with error messages that are designed for novices. Clojure is a Lisp built on top of the Java programming language which better supports concurrent and parallel programming and has been rapidly gaining popularity in industry. However, Clojure was not developed with beginner programmers in mind: its native error messages are often just Java error messages that don’t make sense to programmers without Java background. Our previous work with Clojure has built an alternative error messages system that we think may be more useful to beginner CS students. 

Our work is a part of the ClojurEd project which aims to use Clojure to teach an introductory CS course. One of the project goals is to provide introductory students with understandable error messages. We attempt to achieve this goal by rephrasing Java errors in terms that are familiar to new Clojure programmers. As a simple example, we replace references to specific Java numeric types, such as “int” and “double”, with just the term “number”. The next stage of the project is to evaluate how well the new messages work for beginner programmers. 

In order to evaluate how helpful our error messages are to beginners, we have designed a usability study comparing the proposed and standard Clojure error messages to each other and to Racket error messages. There are very few published usability studies of error messages and very few guidelines for evaluating quality of error messages, thus we have developed methodology for comparing error messages in two similar languages. We evaluate the effectiveness of our error messages by giving students, who are familiar with Racket, erroneous code in both Racket and Clojure. We will then observe how the information presented within the error messages helps them to correct the erroneous code. Effectiveness of error messages will primarily be measured by the number of code samples successfully corrected by students, as well as the number of attempts is takes a student to correct the errors. 

In this paper we present the details of the study and the approaches to developing code samples that allow us to compare error messages systems. We also present and discuss preliminary results of the usability study. 
\emcomment{This would need to be modified after we've finished the paper}
\newpage
\setcounter{page}{1}

\section{Introduction}\label{sec:intro}
	\hfcomment{Elena}
	\subsection{Goals}\label{sec:goals}
	\hfcomment{This needs to describe error messages briefly. Reference previous project.}
\section{Languages}\label{sec:lang}
	\hfcomment{Henry}
	\subsection{Overview of Lisp}\label{sec:lisp}

	Lisp is a family of programming languages that dates from 1958, based on Alonzo Church's lambda calculus 
	%\emcomment{Lisp is definitely based on the lambda calculus, but it wasn't created from it. In particular, lambda calculus is call by name (in its classical form)}
	 by John McCarthy. Lisp was the first language where the internal representation of the program was in the same data structures the program was written in. \hfcomment{???} Lisp has a distinctive fully parenthesized prefix notation, where all code and data are written as expressions in the form:
	\begin{verbatim}
	(<function-name> <argument 1> <argument 2> ... <argument N>)
	\end{verbatim}
Almost all operations are functions. Addition, for instance, is a function that can be applied to any number of arguments.
	\begin{verbatim}
	(+ 2 4 6 8)
	-> 20
	\end{verbatim}
Note that \texttt{->} indicates the result of computations in the Lisp interpreter. Lists in lisp are commonly created by using the list function
 	\begin{verbatim}
	(list 2 4 6 8)
	-> '(2 4 6 8)
	\end{verbatim}
The return value \texttt{'(2 4 6 8)} uses the single quote \texttt{'} to indicate that the expression should not be evaluated (doing so would attempt to apply the number \texttt{2} as a function), but instead it should be treated as list \hfcomment{wrong, but close enough to the truth?}	
	\begin{verbatim}
	(list 2 4 6 8)
	-> '(2 4 6 8)
	\end{verbatim}
	
	Felleisen et al~\cite{Felleisen:2004} have made an excellent case for using a Lisp as a programming language in an introductory CS class
	\emcomment{To be fair, though, they weren't the first ones to use it (SICP was the prior approach)}:
the first language new programmers will use. Lisp offers a simple
syntax and introduces students to modularity, abstraction, and
data-driven program design while developing good programming
practices by being explicit about program design principles.
Teaching these concepts in introductory courses creates a foundation that later classes can build upon in  while teaching popular imperative and object-oriented languages.~\cite{Bieniusa:2008}.\hfcomment{grab from mics 2015 bib} 

\emcomment{We use hashmaps; need to mention those}
	\subsection{Differences between Racket and Clojure}\label{sec:diff}
	
Racket \hfcomment{Beginning student language?} and Clojure, while still lisps, satisfy different design goals. 
Racket is designed for introductory students, while Clojure focuses on concurrency and integration with the Java virtual machine. 
The differing purposes of these language have created divides in the syntax and idioms of Racket and Clojure.
 The differences begin at definition of variables; Clojure defines functions with the following syntax

\begin{verbatim}
	(defn function-name [<argument 1> ... <argument N>] (expression))
	e.g
	(defn plus-four [x] (+ x 4))
\end{verbatim}
Racket uses this syntax:
\begin{verbatim}
	(define (function-name <argument 1> ... <argument N>) (expression))
	e.g
	(define (plus-four x) (+ x 4))
\end{verbatim}

Racket and Clojure both have associative datatypes, and Clojure actually has two. We used hashmaps in the study, simply because they are far more common than the alternative.
Hashmaps in Clojure are a collection of key-value pairs: 

\begin{verbatim}
	{key value, key value, key value}
\end{verbatim}

Hashmaps commonly use keywords. Keywords are simple names that have a colon in front.
An example of a hashmap using keywords follows: 

\begin{verbatim}
	{:a 1, :b 2, :c 3}#<position>
	
	(:a {:a 1, :b 2, :c 3})
	-> 1
\end{verbatim}

The keywords in the above hashmap are: \texttt{:a}, \texttt{:b}, and \texttt{:c}.
Keywords are often used as keys within hashmaps. 
When used as a function on a hashmap, keywords return the value associated with the keyword. 
In the above example, \texttt{:a} is bound to \texttt{1},\texttt{:b} is bound to \texttt{2}, and \texttt{:c} is bound to \texttt{3}.


Racket uses structs as its associative datatype, which has the following syntax:
\begin{verbatim}
	(struct position (x y))
	
	(position 75 42)
	-> #<position>
\end{verbatim}
Structs automatically generate an accessor function for each field in the structure.
\begin{verbatim}
	(position-x (position 75 42))
	-> 75
\end{verbatim}
\section{Usability Study}\label{sec:study}
	\subsection{Objectives}\label{sec:obj}
	\hfcomment{Elena}
	\subsection{Experimental Setup}\label{sec:setup}
	\hfcomment{Thomas, Sean}
		\thcomment{Whats going to happen in terms of presenting to students, how they'll get the code, how we'll be using racket vs clojure. Clearly describing what we're doing technical to the point of what students are presented with, what we'll give them overview. Each student will have alternating examples presented. Website presentation to the students. What is being measured from this. Exit questions given to students.}

\emcomment{Levels of questions}

Outline: \emcomment{I am guessing this isn't the actual paper text:}
\begin{itemize}
\item Students will be given a Racket review
\item Students will be given a Clojure lesson
\item Students will be assigned an instructor
\item Each student will be presented with questions
\item The questions will be Racket and Clojure questions
\item The error messages of the Clojure questions will either be our error messages or Clojure's default error messages
\item The error messages of the Racket questions will always be default Racket
\item Students will be presented these questions through a website we have set up
\item The questions will be randomized in order and which student receives what type of errors
\item The errors students create and their current code will be captured via screencap when they evaluate their code and it returns an error
\end{itemize}
This will give us insight into how students act when presented with the same problem across different languages based on the set of errors that language uses.

	The participants in the study will be gathered into a common space \emcomment{Actually, no, they will be working individually} at the start so that we can familiarize the students with Clojure as well as review Racket, which they should already be familiar with at some level. The Racket section will cover basic functionality in Racket such as prefix notation, higher order functions, function definition, and recursion. The Clojure introduction will follow, covering similar topics and how they translate from Racket outlining the underlying similarities with functional languages. Clojures lesson will cover the same material in the syntax of Clojure, with the addition of introducing participants to Clojure's hashes as well. The overall goal of this instructional session is to not only educate the participants such that the problems to be presented to them will be solvable, but also to ensure a relatively similar level of familiarity with both Clojure and Racket. \emcomment{Not sure if it's grammatically correct; in any case very difficult to parse.}

	After the educational part of the study, the participants will be assigned to a computer. They will be directed to a website we have constructed that will present them with problems to solve in both Racket and Clojure. The set of potential problems that any one participant could receive will be randomized and the type of error messages received will be randomized as well. \emcomment{More specifically: they will get each problem in Racket or in Clojure; which problem is in which language will be randomized; also some will be working with the current Clojure messages, and some with ours.}
Participants will also be allowed to use Racket's IDE and a Clojure project in Lighttable \emcomment{explain}  setup \emcomment{set up? You mean the verb, not the noun, right?} by us ahead of time. The participants will be allocated a timelimit of 30 minutes to answer the questions given. They are allowed to try as many times as needed on each questions and they are allowed to skip past questions with the possibility of coming back to them later on. Once the time limit has expired the participants will no longer be able to submit answers and they will be allowed to leave. After the question period of the study, we will now have a collection of screen captures from each participant detailing the process solving the problems. From these we can begin to gauge the significance of the error messages in their problem solving processes. 
\emcomment{Followup questions; explain how we are going to evaluate the results.}

	
	

\section{Principles of Question Selection}\label{sec:select}
	\hfcomment{Henry + Elena}
	\subsection{Selecting Meaningful Accessible Questions}\label{sec:meaning}
	\hfcomment{Elena}
	\subsection{Question parallelism}\label{sec:parallel}
	\hfcomment{Henry}
	both features - don't use vectors, cond, no loop recur in clojure
	One of the overarching themes of this study was the difficulty in creating questions that had similar meaning, errors, and syntax in both Clojure and Racket.
	 Often, our questions are somewhat less than idiomatic because of the constraints imposed by the short time commitment we intended for the study.
	  For instance, we only use lists in our questions, where idiomatic Clojure prefers vectors, which combine the best features of arrays and lists.
	   Reducing the amount of review and potential sources of confusion was paramount. 
	   For instance, Clojure doesn't support tail recursion properly because of the limitations of the Java virtual machine.
	    In order to create tail-recursive structures, idiomatic Clojure uses a construct called loop recur to bypass this limitation. \hfcomment{Cond?}
\section{Examples}\label{sec:examples}
	\hfcomment{Sean, Thomas}

\section{Conclusion}\label{sec:conclusion}
	\hfcomment{Elena}

\bibliographystyle{acm}
\bibliography{mics2016}

% That's all folks!
\end{document}
